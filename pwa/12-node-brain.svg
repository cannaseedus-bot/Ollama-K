<?xml version="1.0" encoding="UTF-8"?>
<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>K'UHUL Brain Cluster - RLHF + IndexedDB Runtime</title>
  
  <defs>
    <!-- CSS Styles -->
    <style><![CDATA[
      .brain-ring { fill: none; stroke: #00ffd0; stroke-width: 2.5; }
      .brain-line { fill: none; stroke: #00ffd0; stroke-width: 2; }
      .brain-fill { fill: #00ffd0; }
      .active { stroke: #ff3366; stroke-width: 3; }
      .learning { animation: pulse 2s infinite; }
      .storing { animation: glow 1.5s infinite; }
      @keyframes pulse { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }
      @keyframes glow { 0%, 100% { filter: drop-shadow(0 0 5px #00ffd0); } 50% { filter: drop-shadow(0 0 15px #00ffd0); } }
      .brain-text { font-family: monospace; font-size: 9px; fill: #00ffd0; }
      .stats-text { font-family: monospace; font-size: 8px; fill: #ff3366; }
      .log-text { font-family: monospace; font-size: 7px; fill: #f5c451; }
    ]]></style>
    
    <!-- Gradient for storage visualization -->
    <linearGradient id="storageGradient" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#00ffd0" stop-opacity="0.8"/>
      <stop offset="1" stop-color="#00aaff" stop-opacity="0.4"/>
    </linearGradient>
    
    <!-- Database icon for RLHF storage -->
    <g id="icon-db">
      <rect x="-12" y="-8" width="24" height="16" rx="3" fill="#00ffd0" opacity="0.2" stroke="#00ffd0" stroke-width="1"/>
      <rect x="-10" y="-6" width="20" height="4" rx="1" fill="#00ffd0" opacity="0.5"/>
      <rect x="-8" y="2" width="16" height="4" rx="1" fill="#00ffd0" opacity="0.3"/>
    </g>
    
    <!-- RLHF feedback icon -->
    <g id="icon-rlhf">
      <circle cx="0" cy="0" r="8" fill="none" stroke="#ff3366" stroke-width="1.5"/>
      <path d="M-4,-2 L4,-2 L4,2 L-4,2 Z" fill="#ff3366" opacity="0.7"/>
      <path d="M-3,4 L0,8 L3,4" fill="#ff3366"/>
    </g>
  </defs>
  
  <!-- Background -->
  <rect width="512" height="512" fill="#05070b"/>
  
  <!-- Main Brain Cluster Grid (4x3) -->
  <g transform="translate(64, 40)">
    <!-- ROW 0: Tokenization, Context, Attention, Reasoning -->
    
    <!-- 0,0 TOKENIZATION -->
    <g id="brain-tokenize" transform="translate(0,0)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="tokenize-ring"/>
      <rect x="14" y="20" width="14" height="9" rx="2" class="brain-fill"/>
      <rect x="32" y="16" width="15" height="10" rx="2" class="brain-ring"/>
      <rect x="49" y="20" width="12" height="9" rx="2" class="brain-ring"/>
      <rect x="20" y="34" width="16" height="9" rx="2" class="brain-fill"/>
      <rect x="42" y="36" width="15" height="9" rx="2" class="brain-ring"/>
      <circle cx="32" cy="32" r="3" class="brain-fill"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Tokenize</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="tokenize-stats">0</text>
    </g>
    
    <!-- 1,0 CONTEXT -->
    <g id="brain-context" transform="translate(96,0)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="context-ring"/>
      <rect x="16" y="20" width="32" height="24" rx="4" class="brain-ring"/>
      <rect x="20" y="22" width="16" height="6" rx="2" class="brain-fill"/>
      <rect x="20" y="30" width="22" height="4" rx="2" class="brain-fill" opacity="0.7"/>
      <rect x="20" y="37" width="18" height="4" rx="2" class="brain-fill" opacity="0.5"/>
      <rect x="20" y="44" width="14" height="4" rx="2" class="brain-fill" opacity="0.3"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Context</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="context-stats">0</text>
    </g>
    
    <!-- 2,0 ATTENTION -->
    <g id="brain-attention" transform="translate(192,0)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="attention-ring"/>
      <path d="M14 32c4-5 11-11 18-11s14 6 18 11c-4 5-11 11-18 11S18 37 14 32z" class="brain-line"/>
      <circle cx="32" cy="32" r="5" class="brain-fill"/>
      <circle cx="32" cy="32" r="10" class="brain-ring" opacity="0.5"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Attention</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="attention-stats">0</text>
    </g>
    
    <!-- 3,0 REASONING -->
    <g id="brain-reason" transform="translate(288,0)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="reason-ring"/>
      <path d="M18 40c3-7 6-11 11-11 7 0 5 10 12 10 4 0 7-3 10-8" class="brain-line"/>
      <circle cx="20" cy="22" r="3" class="brain-fill"/>
      <circle cx="30" cy="27" r="3" class="brain-fill"/>
      <circle cx="40" cy="24" r="3" class="brain-fill"/>
      <line x1="20" y1="22" x2="30" y2="27" class="brain-line" stroke-width="1.5"/>
      <line x1="30" y1="27" x2="40" y2="24" class="brain-line" stroke-width="1.5"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Reasoning</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="reason-stats">0</text>
    </g>
    
    <!-- ROW 1: Routing, Execution, Compression, Memory -->
    
    <!-- 0,1 ROUTING -->
    <g id="brain-routing" transform="translate(0,96)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="routing-ring"/>
      <circle cx="32" cy="32" r="5" class="brain-fill"/>
      <path d="M32 32L18 18M32 32L46 18M32 32L18 46M32 32L46 46" class="brain-line"/>
      <circle cx="18" cy="18" r="3.5" class="brain-ring"/>
      <circle cx="46" cy="18" r="3.5" class="brain-ring"/>
      <circle cx="18" cy="46" r="3.5" class="brain-ring"/>
      <circle cx="46" cy="46" r="3.5" class="brain-ring"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Routing</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="routing-stats">0</text>
    </g>
    
    <!-- 1,1 EXECUTION -->
    <g id="brain-exec" transform="translate(96,96)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="exec-ring"/>
      <rect x="18" y="22" width="28" height="20" rx="3" class="brain-ring"/>
      <polygon points="24,24 38,32 24,40" class="brain-fill"/>
      <rect x="20" y="44" width="24" height="3" rx="1.5" class="brain-fill"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Execution</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="exec-stats">0</text>
    </g>
    
    <!-- 2,1 COMPRESSION -->
    <g id="brain-compress" transform="translate(192,96)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="compress-ring"/>
      <rect x="14" y="20" width="14" height="10" rx="2" class="brain-ring"/>
      <rect x="40" y="34" width="14" height="10" rx="2" class="brain-fill"/>
      <path d="M28 25h6l2.5 5 2.5-5h6" class="brain-line"/>
      <path d="M34 38h-5" class="brain-line"/>
      <path d="M40 26L48 32" class="brain-line" stroke-dasharray="3 2"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Compression</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="compress-stats">0</text>
    </g>
    
    <!-- 3,1 MEMORY -->
    <g id="brain-memory" transform="translate(288,96)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="memory-ring"/>
      <rect x="18" y="20" width="18" height="24" rx="3" class="brain-ring"/>
      <rect x="32" y="20" width="18" height="24" rx="3" class="brain-ring" opacity="0.6"/>
      <line x1="20" y1="25" x2="34" y2="25" class="brain-line"/>
      <line x1="20" y1="31" x2="34" y2="31" class="brain-line"/>
      <line x1="34" y1="25" x2="46" y2="25" class="brain-line" opacity="0.7"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Memory</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="memory-stats">0</text>
    </g>
    
    <!-- ROW 2: Safety, Generation, Self-correction, Knowledge -->
    
    <!-- 0,2 SAFETY -->
    <g id="brain-safety" transform="translate(0,192)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="safety-ring"/>
      <path d="M32 16l12 7v10c0 8-6 14-12 16-6-2-12-8-12-16V23z" class="brain-line"/>
      <circle cx="32" cy="29" r="4" class="brain-fill"/>
      <rect x="28" y="35" width="8" height="9" class="brain-fill"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Safety</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="safety-stats">0</text>
    </g>
    
    <!-- 1,2 GENERATION -->
    <g id="brain-generate" transform="translate(96,192)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="generate-ring"/>
      <path d="M20 40c3-6 7-9 11-9 5 0 8 3 12 3 4 0 8-3 11-7" class="brain-line"/>
      <circle cx="22" cy="24" r="3" class="brain-fill"/>
      <circle cx="32" cy="23" r="3" class="brain-fill"/>
      <circle cx="42" cy="26" r="3" class="brain-fill"/>
      <path d="M38 16l3 4 4 1.5-4 1.5-3 4-1.5-4-4-1.5 4-1.5z" class="brain-fill"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Generation</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="generate-stats">0</text>
    </g>
    
    <!-- 2,2 SELF-CORRECTION -->
    <g id="brain-correct" transform="translate(192,192)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="correct-ring"/>
      <path d="M20 38c3-7 7-11 12-11 6 0 10 4 13 11" class="brain-line"/>
      <path d="M22 24l8 6 14-14" class="brain-line" stroke-width="2.5"/>
      <circle cx="22" cy="24" r="3" class="brain-fill"/>
      <circle cx="44" cy="16" r="3" class="brain-fill"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Correction</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="correct-stats">0</text>
    </g>
    
    <!-- 3,2 KNOWLEDGE -->
    <g id="brain-knowledge" transform="translate(288,192)">
      <circle cx="32" cy="32" r="22" class="brain-ring" id="knowledge-ring"/>
      <path d="M18 40V26l8-3 8 3 8-3 8 3v14" class="brain-line"/>
      <line x1="26" y1="23" x2="26" y2="42" class="brain-line" stroke-width="1.5"/>
      <line x1="38" y1="20" x2="38" y2="42" class="brain-line" stroke-width="1.5"/>
      <text x="32" y="68" text-anchor="middle" class="brain-text">Knowledge</text>
      <text x="32" y="76" text-anchor="middle" class="stats-text" id="knowledge-stats">0</text>
    </g>
  </g>
  
  <!-- RLHF Storage Visualization -->
  <g transform="translate(256, 320)">
    <!-- Storage Hub -->
    <circle cx="0" cy="0" r="40" fill="none" stroke="url(#storageGradient)" stroke-width="4" opacity="0.3"/>
    <use xlink:href="#icon-db" x="0" y="0"/>
    
    <!-- Storage Stats -->
    <text x="0" y="-50" text-anchor="middle" class="brain-text" font-size="10">RLHF Storage</text>
    <text x="0" y="-35" text-anchor="middle" class="stats-text" id="storage-status">IndexedDB: Ready</text>
    <text x="0" y="40" text-anchor="middle" class="brain-text" font-size="9" id="rlhf-count">0 RLHF events</text>
    <text x="0" y="50" text-anchor="middle" class="stats-text" id="feedback-count">0 feedback items</text>
    <text x="0" y="60" text-anchor="middle" class="log-text" id="last-rlhf">No RLHF data yet</text>
  </g>
  
  <!-- Control Panel -->
  <g transform="translate(256, 400)">
    <rect x="-100" y="-15" width="200" height="30" rx="6" fill="rgba(5,7,11,0.8)" stroke="#00ffd0" stroke-width="1"/>
    
    <!-- Save RLHF Button -->
    <g transform="translate(-60, 0)" style="cursor: pointer">
      <circle cx="0" cy="0" r="8" fill="#00ffd0" opacity="0.7"/>
      <rect x="-3" y="-4" width="6" height="8" fill="#05070b" rx="1"/>
      <text x="0" y="20" text-anchor="middle" class="log-text">Save RLHF</text>
    </g>
    
    <!-- Load Training Data -->
    <g transform="translate(-20, 0)" style="cursor: pointer">
      <circle cx="0" cy="0" r="8" fill="#ff3366" opacity="0.7"/>
      <path d="M-5,3 L5,3 L0,-4 Z" fill="#05070b"/>
      <text x="0" y="20" text-anchor="middle" class="log-text">Load Data</text>
    </g>
    
    <!-- Clear Data -->
    <g transform="translate(20, 0)" style="cursor: pointer">
      <circle cx="0" cy="0" r="8" fill="#f5c451" opacity="0.7"/>
      <path d="M-4,-4 L4,4 M4,-4 L-4,4" stroke="#05070b" stroke-width="2"/>
      <text x="0" y="20" text-anchor="middle" class="log-text">Clear</text>
    </g>
    
    <!-- Export Data -->
    <g transform="translate(60, 0)" style="cursor: pointer">
      <circle cx="0" cy="0" r="8" fill="#a78bfa" opacity="0.7"/>
      <rect x="-3" y="-3" width="6" height="6" fill="#05070b"/>
      <path d="M0,-5 L0,-2" stroke="#05070b" stroke-width="2"/>
      <text x="0" y="20" text-anchor="middle" class="log-text">Export</text>
    </g>
  </g>
  
  <!-- Activity Log -->
  <g transform="translate(256, 450)">
    <rect x="-180" y="-15" width="360" height="30" rx="6" fill="rgba(5,7,11,0.7)" stroke="#f5c451" stroke-width="1"/>
    <text x="-170" y="-2" text-anchor="start" class="log-text">Activity:</text>
    <text x="-140" y="-2" text-anchor="start" class="log-text" id="current-activity">Brain cluster idle</text>
    <text x="170" y="-2" text-anchor="end" class="log-text" id="activity-time">-</text>
  </g>
  
  <!-- RLHF Embedded Runtime -->
  <script type="application/javascript">
<![CDATA[
    // K'UHUL Brain Cluster RLHF Runtime
    // IndexedDB for RLHF data storage and event logging
    
    class RLHFBrainCluster {
      constructor() {
        // Brain node activity tracking
        this.brainNodes = {
          'tokenize': { count: 0, lastActive: 0 },
          'context': { count: 0, lastActive: 0 },
          'attention': { count: 0, lastActive: 0 },
          'reason': { count: 0, lastActive: 0 },
          'routing': { count: 0, lastActive: 0 },
          'exec': { count: 0, lastActive: 0 },
          'compress': { count: 0, lastActive: 0 },
          'memory': { count: 0, lastActive: 0 },
          'safety': { count: 0, lastActive: 0 },
          'generate': { count: 0, lastActive: 0 },
          'correct': { count: 0, lastActive: 0 },
          'knowledge': { count: 0, lastActive: 0 }
        };
        
        // RLHF data storage
        this.storage = {
          db: null,
          ready: false,
          stats: {
            rlhfEvents: 0,
            feedbackItems: 0,
            trainingSessions: 0,
            lastUpdated: null
          }
        };
        
        // Initialize IndexedDB for RLHF storage
        this.initRLHFStorage();
        
        // Setup click handlers
        this.setupEventHandlers();
        
        // Start activity simulation
        this.startBrainActivity();
        
        // Update display
        this.updateAllDisplays();
        
        console.log('ðŸ§  RLHF Brain Cluster initialized');
      }
      
      // Initialize IndexedDB for RLHF data
      async initRLHFStorage() {
        try {
          if (!window.indexedDB) {
            this.updateStorageStatus('IndexedDB not available');
            return;
          }
          
          const request = indexedDB.open('kuhul-brain-rlhf', 3);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            
            // RLHF Events Store
            if (!db.objectStoreNames.contains('rlhf_events')) {
              const eventsStore = db.createObjectStore('rlhf_events', { keyPath: 'id' });
              eventsStore.createIndex('timestamp', 'timestamp', { unique: false });
              eventsStore.createIndex('brainNode', 'brainNode', { unique: false });
              eventsStore.createIndex('feedbackScore', 'feedbackScore', { unique: false });
            }
            
            // Feedback Training Store
            if (!db.objectStoreNames.contains('feedback_data')) {
              const feedbackStore = db.createObjectStore('feedback_data', { keyPath: 'id' });
              feedbackStore.createIndex('sessionId', 'sessionId', { unique: false });
              feedbackStore.createIndex('quality', 'quality', { unique: false });
              feedbackStore.createIndex('tags', 'tags', { unique: false, multiEntry: true });
            }
            
            // Training Sessions Store
            if (!db.objectStoreNames.contains('training_sessions')) {
              const trainingStore = db.createObjectStore('training_sessions', { keyPath: 'id' });
              trainingStore.createIndex('startTime', 'startTime', { unique: false });
              trainingStore.createIndex('status', 'status', { unique: false });
            }
            
            // Model Snapshots Store
            if (!db.objectStoreNames.contains('model_snapshots')) {
              const snapshotsStore = db.createObjectStore('model_snapshots', { keyPath: 'version' });
              snapshotsStore.createIndex('created', 'created', { unique: false });
              snapshotsStore.createIndex('performance', 'performance', { unique: false });
            }
          };
          
          request.onsuccess = (event) => {
            this.storage.db = event.target.result;
            this.storage.ready = true;
            
            // Load stats from storage
            this.loadStorageStats();
            
            this.updateStorageStatus('IndexedDB: Ready');
            this.logActivity('RLHF storage initialized');
            
            // Setup button handlers after storage is ready
            this.setupButtonHandlers();
          };
          
          request.onerror = (event) => {
            console.error('RLHF IndexedDB error:', event.target.error);
            this.updateStorageStatus('IndexedDB: Error');
          };
          
        } catch (error) {
          console.error('RLHF storage init error:', error);
          this.updateStorageStatus('Storage error');
        }
      }
      
      // Setup event handlers for brain nodes
      setupEventHandlers() {
        // Add click handlers to each brain node for manual triggering
        Object.keys(this.brainNodes).forEach(nodeId => {
          const element = document.getElementById(`brain-${nodeId}`);
          if (element) {
            element.onclick = () => this.triggerBrainNode(nodeId);
          }
        });
      }
      
      // Setup button handlers
      setupButtonHandlers() {
        const buttons = document.querySelectorAll('g[style*="cursor: pointer"]');
        
        if (buttons[0]) buttons[0].onclick = () => this.saveRLHFEvent();
        if (buttons[1]) buttons[1].onclick = () => this.loadTrainingData();
        if (buttons[2]) buttons[2].onclick = () => this.clearRLHFData();
        if (buttons[3]) buttons[3].onclick = () => this.exportRLHFData();
      }
      
      // Save RLHF event
      async saveRLHFEvent(brainNode = null, feedbackScore = null, data = null) {
        if (!this.storage.ready) {
          this.logActivity('Storage not ready for RLHF save');
          return null;
        }
        
        try {
          const node = brainNode || this.getRandomBrainNode();
          const score = feedbackScore || this.generateFeedbackScore();
          const eventData = data || {
            input: this.generateRandomInput(),
            response: this.generateRandomResponse(),
            context: { timestamp: Date.now(), session: this.generateSessionId() }
          };
          
          const rlhfEvent = {
            id: `rlhf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: Date.now(),
            brainNode: node,
            feedbackScore: score,
            data: eventData,
            sessionId: this.generateSessionId(),
            metadata: {
              version: '1.0',
              source: 'brain-cluster',
              tags: ['rlhf', node, score > 0.7 ? 'positive' : 'neutral']
            }
          };
          
          const transaction = this.storage.db.transaction(['rlhf_events'], 'readwrite');
          const store = transaction.objectStore('rlhf_events');
          
          await store.add(rlhfEvent);
          
          // Update brain node stats
          this.brainNodes[node].count++;
          this.brainNodes[node].lastActive = Date.now();
          
          // Update storage stats
          this.storage.stats.rlhfEvents++;
          this.storage.stats.lastUpdated = Date.now();
          
          // Highlight the brain node
          this.highlightBrainNode(node);
          
          // Update displays
          this.updateNodeDisplay(node);
          this.updateStorageDisplay();
          
          this.logActivity(`RLHF saved: ${node} (score: ${score.toFixed(2)})`);
          
          return rlhfEvent;
          
        } catch (error) {
          console.error('RLHF save error:', error);
          this.logActivity('RLHF save failed');
          return null;
        }
      }
      
      // Save feedback training data
      async saveFeedbackTraining(feedbackData) {
        if (!this.storage.ready) return null;
        
        try {
          const feedback = {
            id: `feedback_${Date.now()}`,
            timestamp: Date.now(),
            sessionId: this.generateSessionId(),
            quality: feedbackData.quality || this.generateQualityScore(),
            categories: feedbackData.categories || ['helpfulness', 'accuracy', 'safety'],
            tags: feedbackData.tags || [],
            notes: feedbackData.notes || '',
            improvements: feedbackData.improvements || [],
            rating: feedbackData.rating || Math.floor(Math.random() * 5) + 1,
            metadata: {
              type: 'human_feedback',
              version: '1.0',
              source: 'brain-cluster-rlhf'
            }
          };
          
          const transaction = this.storage.db.transaction(['feedback_data'], 'readwrite');
          const store = transaction.objectStore('feedback_data');
          
          await store.add(feedback);
          
          this.storage.stats.feedbackItems++;
          this.updateStorageDisplay();
          
          this.logActivity(`Feedback saved (quality: ${feedback.quality.toFixed(2)})`);
          
          return feedback;
          
        } catch (error) {
          console.error('Feedback save error:', error);
          return null;
        }
      }
      
      // Load training data from storage
      async loadTrainingData(limit = 50) {
        if (!this.storage.ready) return [];
        
        try {
          const transaction = this.storage.db.transaction(['rlhf_events'], 'readonly');
          const store = transaction.objectStore('rlhf_events');
          const index = store.index('timestamp');
          
          const request = index.openCursor(null, 'prev');
          const results = [];
          
          return new Promise((resolve, reject) => {
            request.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor && results.length < limit) {
                results.push(cursor.value);
                cursor.continue();
              } else {
                this.logActivity(`Loaded ${results.length} RLHF events`);
                resolve(results);
              }
            };
            
            request.onerror = reject;
          });
          
        } catch (error) {
          console.error('Load training data error:', error);
          return [];
        }
      }
      
      // Clear RLHF data
      async clearRLHFData() {
        if (!this.storage.ready) return;
        
        try {
          const stores = ['rlhf_events', 'feedback_data', 'training_sessions', 'model_snapshots'];
          
          for (const storeName of stores) {
            const transaction = this.storage.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            await store.clear();
          }
          
          // Reset stats
          this.storage.stats = {
            rlhfEvents: 0,
            feedbackItems: 0,
            trainingSessions: 0,
            lastUpdated: null
          };
          
          // Reset brain node counts
          Object.keys(this.brainNodes).forEach(node => {
            this.brainNodes[node].count = 0;
          });
          
          this.updateAllDisplays();
          this.logActivity('RLHF data cleared');
          
        } catch (error) {
          console.error('Clear RLHF data error:', error);
        }
      }
      
      // Export RLHF data
      async exportRLHFData() {
        try {
          const exportData = {
            metadata: {
              exportDate: new Date().toISOString(),
              version: '2.0',
              source: 'KUHUL Brain Cluster RLHF'
            },
            stats: this.storage.stats,
            brainNodeActivity: this.brainNodes,
            recentRLHFEvents: await this.loadTrainingData(100),
            summary: {
              totalEvents: this.storage.stats.rlhfEvents,
              totalFeedback: this.storage.stats.feedbackItems,
              activeNodes: Object.keys(this.brainNodes).filter(k => this.brainNodes[k].count > 0).length
            }
          };
          
          const dataStr = JSON.stringify(exportData, null, 2);
          const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
          
          const link = document.createElement('a');
          link.setAttribute('href', dataUri);
          link.setAttribute('download', `kuhul-brain-rlhf-${Date.now()}.json`);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          this.logActivity('RLHF data exported');
          
        } catch (error) {
          console.error('Export error:', error);
          this.logActivity('Export failed');
        }
      }
      
      // Load storage stats
      async loadStorageStats() {
        if (!this.storage.ready) return;
        
        try {
          // Count RLHF events
          const eventsTransaction = this.storage.db.transaction(['rlhf_events'], 'readonly');
          const eventsStore = eventsTransaction.objectStore('rlhf_events');
          const eventsCount = await eventsStore.count();
          
          // Count feedback items
          const feedbackTransaction = this.storage.db.transaction(['feedback_data'], 'readonly');
          const feedbackStore = feedbackTransaction.objectStore('feedback_data');
          const feedbackCount = await feedbackStore.count();
          
          this.storage.stats.rlhfEvents = eventsCount.result || 0;
          this.storage.stats.feedbackItems = feedbackCount.result || 0;
          
          this.updateStorageDisplay();
          
        } catch (error) {
          console.error('Load stats error:', error);
        }
      }
      
      // Start brain activity simulation
      startBrainActivity() {
        // Simulate random brain node activity
        setInterval(() => {
          if (Math.random() > 0.7) { // 30% chance of activity
            const node = this.getRandomBrainNode();
            this.triggerBrainNode(node);
            
            // Occasionally save as RLHF event
            if (Math.random() > 0.8) { // 20% chance
              this.saveRLHFEvent(node);
            }
          }
        }, 3000);
        
        // Periodic storage sync
        setInterval(() => {
          this.updateAllDisplays();
        }, 5000);
      }
      
      // Trigger brain node activity
      triggerBrainNode(nodeId) {
        if (!this.brainNodes[nodeId]) return;
        
        this.brainNodes[nodeId].count++;
        this.brainNodes[nodeId].lastActive = Date.now();
        
        this.highlightBrainNode(nodeId);
        this.updateNodeDisplay(nodeId);
        
        this.logActivity(`Brain node active: ${nodeId}`);
      }
      
      // Highlight brain node
      highlightBrainNode(nodeId) {
        const ring = document.getElementById(`${nodeId}-ring`);
        if (ring) {
          ring.classList.add('active');
          setTimeout(() => ring.classList.remove('active'), 1000);
        }
      }
      
      // Update all displays
      updateAllDisplays() {
        this.updateNodeDisplays();
        this.updateStorageDisplay();
      }
      
      // Update node displays
      updateNodeDisplays() {
        Object.keys(this.brainNodes).forEach(node => {
          this.updateNodeDisplay(node);
        });
      }
      
      // Update single node display
      updateNodeDisplay(nodeId) {
        const statsElement = document.getElementById(`${nodeId}-stats`);
        if (statsElement) {
          statsElement.textContent = this.brainNodes[nodeId].count;
          
          // Add animation for new activity
          if (Date.now() - this.brainNodes[nodeId].lastActive < 1000) {
            statsElement.style.transform = 'scale(1.3)';
            setTimeout(() => {
              statsElement.style.transform = 'scale(1)';
            }, 300);
          }
        }
      }
      
      // Update storage display
      updateStorageDisplay() {
        const rlhfElement = document.getElementById('rlhf-count');
        const feedbackElement = document.getElementById('feedback-count');
        const lastRLHFElement = document.getElementById('last-rlhf');
        
        if (rlhfElement) {
          rlhfElement.textContent = `${this.storage.stats.rlhfEvents} RLHF events`;
        }
        
        if (feedbackElement) {
          feedbackElement.textContent = `${this.storage.stats.feedbackItems} feedback items`;
        }
        
        if (lastRLHFElement && this.storage.stats.lastUpdated) {
          const timeAgo = Math.floor((Date.now() - this.storage.stats.lastUpdated) / 1000);
          lastRLHFElement.textContent = `Last: ${timeAgo}s ago`;
        }
      }
      
      // Update storage status
      updateStorageStatus(status) {
        const element = document.getElementById('storage-status');
        if (element) {
          element.textContent = status;
        }
      }
      
      // Log activity
      logActivity(message) {
        const activityElement = document.getElementById('current-activity');
        const timeElement = document.getElementById('activity-time');
        
        if (activityElement) {
          activityElement.textContent = message.length > 40 ? message.substring(0, 40) + '...' : message;
        }
        
        if (timeElement) {
          timeElement.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        console.log(`ðŸ§  ${message}`);
      }
      
      // Utility methods
      getRandomBrainNode() {
        const nodes = Object.keys(this.brainNodes);
        return nodes[Math.floor(Math.random() * nodes.length)];
      }
      
      generateFeedbackScore() {
        // Generate somewhat positive scores (0.4-0.9)
        return 0.4 + Math.random() * 0.5;
      }
      
      generateQualityScore() {
        // Quality score 0-1
        return Math.random();
      }
      
      generateRandomInput() {
        const inputs = [
          "Explain quantum computing",
          "Write a poem about AI",
          "Help debug this code",
          "Summarize this article",
          "Translate to Spanish",
          "Generate creative ideas",
          "Analyze this data",
          "Create a story"
        ];
        return inputs[Math.floor(Math.random() * inputs.length)];
      }
      
      generateRandomResponse() {
        const responses = [
          "Quantum computing uses qubits...",
          "Here's a poem about artificial intelligence...",
          "I found the bug in your code...",
          "The article discusses...",
          "La traducciÃ³n al espaÃ±ol es...",
          "Here are some creative ideas...",
          "The data shows a trend of...",
          "Once upon a time in a digital world..."
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }
      
      generateSessionId() {
        return 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }
      
      // Public API
      getAPI() {
        return {
          saveRLHF: (node, score, data) => this.saveRLHFEvent(node, score, data),
          saveFeedback: (data) => this.saveFeedbackTraining(data),
          loadData: (limit) => this.loadTrainingData(limit),
          clearData: () => this.clearRLHFData(),
          exportData: () => this.exportRLHFData(),
          getStats: () => ({
            brainNodes: this.brainNodes,
            storageStats: this.storage.stats,
            totalActivity: Object.values(this.brainNodes).reduce((sum, node) => sum + node.count, 0)
          }),
          triggerNode: (nodeId) => this.triggerBrainNode(nodeId)
        };
      }
    }
    
    // Initialize RLHF Brain Cluster
    let rlhfBrainCluster;
    
    function initRLHFBrainCluster() {
      try {
        rlhfBrainCluster = new RLHFBrainCluster();
        window.rlhfBrainCluster = rlhfBrainCluster;
        
        console.log('ðŸ§  RLHF Brain Cluster with IndexedDB initialized');
        
        // Test RLHF save after initialization
        setTimeout(() => {
          if (rlhfBrainCluster) {
            rlhfBrainCluster.saveRLHFEvent();
            rlhfBrainCluster.saveFeedbackTraining({
              quality: 0.85,
              categories: ['accuracy', 'helpfulness'],
              notes: 'Good response, could be more concise'
            });
          }
        }, 2000);
        
      } catch (error) {
        console.error('Failed to initialize RLHF Brain Cluster:', error);
      }
    }
    
    // Initialize when ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initRLHFBrainCluster);
    } else {
      initRLHFBrainCluster();
    }
    
    // Global access
    window.KuhulBrainRLHF = {
      getInstance: () => rlhfBrainCluster,
      getAPI: () => rlhfBrainCluster?.getAPI()
    };
]]>
  </script>
</svg>
